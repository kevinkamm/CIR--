function [params, ctimes, errors, methods]=calibrationMC(T,dW1,dW2,...
                                    strikeSwap,maturitySwap,tenorSwap,...
                                    P0TMarket,modelTimes,marketPrice,...
                                    swapType,varargin)
%%CALIBRATIONMONTECARLO calibrates the CIR-- model to the selected 
% swaption prices using Monte-Carlo techniques.
%    Input:
%       strikeSwap (p x q array): strikes of swaption 
%       maturitySwap (p x 1 array): maturities of swaption
%       tenorSwap (1 x q array): tenors of swaption
%       P0TMarket (griddedInterpolant): interpolated market zero coupon 
%                                       prices
%       marketPrice (p x q array): market prices of swaption
%       dW1 (N-1 x M array): Brownian increment for CIR process x
%       dW2 (N-1 x M array): Brownian increment for CIR process y
%       modelTimes (N x 1 array): contains the timeline of the model
%       swapType (int): equal to 1 for payer swaption and -1 for receiver
%       varargin (cell array): contains optional name-value pairs
%           'compMode': 'subMatrix' (default), 'coordinates'
%           'coordinates': cell array
%    Output:
%       params (d x 1 cell array): calibrated parameters
%       ctimes (d x 1 cell array): computational times
%       errors (d x 1 cell array): calibration error, value of fminGC
%       methods (d x 1 cell array): calibration methods or which initial
%                                   datum
%
% See also fmincon, ga, GramCharlier_0T, linconstr, subsetSum, fminGC

swaptionType='payer';
compMode='subMatrix';
coords={};
for kk=1:2:length(varargin)
    switch varargin{kk}
        case 'swaptionType'
            swaptionType=varargin{kk+1};
        case 'compMode'
            compMode=varargin{kk+1};
        case 'coordinates'
            coords=varargin{kk+1};
    end
end

% linear constraint matrix
[A,b] = linconstr();

% optimization options
tolCon=1e-12;
optsGa = optimoptions('ga',...
                    'ConstraintTolerance',tolCon,...
                    'UseParallel',true);
opts = optimoptions('fmincon',...
                    'MaxFunctionEvaluations',100000,...
                    'MaxIterations',10000,...
                    'TolCon',tolCon,...
                    'UseParallel',true);

% params= $[\phi_1^x,...,\phi_1^y,...\phi_3^y,x_0,y_0]$
% lower and upper bounds
lb=1e-4*ones(1,8);
% Feller conditions
 lb(3)=1;lb(6)=1;
% for convenience
ub=1*ones(1,8);
ub(3)=2;ub(6)=2; 
ub(7)= 1e-1;
ub(8) = 1e-1;

% Global optimization
% disp('Start global optimization')
% ticGa=tic;
% [paramGa,errGa] = ga(@(params)fminMC(params,T,dW1,dW2,strikeSwap,maturitySwap,tenorSwap,...
%                       P0TMarket,modelTimes,marketPrice,...
%                       swapType,...
%                       'compMode',compMode,...
%                       'coordinates',coords),...
%                      8,...
%                      A,b,...
%                      [],[],...
%                      lb,ub,...
%                      [],optsGa);
% ctimeGa=toc(ticGa);
% fprintf('Finished global optimization with err=%1.3e after %3.3f seconds\n',errGa,ctimeGa)
% 
% % Initial datum ga
% disp('Start local optimization with ga input')
% ticGaFmin=tic;
% [paramGaFmin,errGaFmin] = fmincon(@(params)fminMC(params,T,dW1,dW2,strikeSwap,maturitySwap,tenorSwap,...
%                   P0TMarket,modelTimes,marketPrice,...
%                   swapType,...
%                   'compMode',compMode,...
%                   'coordinates',coords),...
%              paramGa,...
%              A,b,...
%              [],[],...
%              lb,ub,...
%              [],...
%              opts);
% ctimeGaFmin=toc(ticGaFmin);
% fprintf('Finished local optimization with err=%1.3e after %3.3f seconds\n',errGaFmin,ctimeGaFmin)

% Initial datum (ub+lb)/2
disp('Start local optimization with (ub+lb)/2')
ticFmin1=tic;
[paramFmin1,errFmin1] = fmincon(@(params)fminMC(params,T,dW1,dW2,strikeSwap,maturitySwap,tenorSwap,...
                  P0TMarket,modelTimes,marketPrice,...
                  swapType,...
                  'compMode',compMode,...
                  'coordinates',coords),...
             (lb+ub)./2,...
             A,b,...
             [],[],...
             lb,ub,...
             [],...
             opts);
ctimeFmin1=toc(ticFmin1);
fprintf('Finished local optimization with err=%1.3e after %3.3f seconds\n',errFmin1,ctimeFmin1)

% Initial datum ub
disp('Start local optimization with admissibile (ub+lb)./10')
ticFmin2=tic;
tempParam=(lb+ub)./10;
tempParam(2)=tempParam(2).*0.95;
tempParam(4)=tempParam(4).*0.95;
[paramFmin2,errFmin2] = fmincon(@(params)fminMC(params,T,dW1,dW2,strikeSwap,maturitySwap,tenorSwap,...
                  P0TMarket,modelTimes,marketPrice,...
                  swapType,...
                  'compMode',compMode,...
                  'coordinates',coords),...
             tempParam,...
             A,b,...
             [],[],...
             lb,ub,...
             [],...
             opts);
ctimeFmin2=toc(ticFmin2);
fprintf('Finished local optimization with err=%1.3e after %3.3f seconds\n',errFmin2,ctimeFmin2)

% Initial datum lb
disp('Start local optimization with lb')
ticFmin3=tic;
[paramFmin3,errFmin3] = fmincon(@(params)fminMC(params,T,dW1,dW2,strikeSwap,maturitySwap,tenorSwap,...
                  P0TMarket,modelTimes,marketPrice,...
                  swapType,...
                  'compMode',compMode,...
                  'coordinates',coords),...
             lb,...
             A,b,...
             [],[],...
             lb,ub,...
             [],...
             opts);
ctimeFmin3=toc(ticFmin3);
fprintf('Finished local optimization with err=%1.3e after %3.3f seconds\n',errFmin3,ctimeFmin3)

% Outputs
params={paramFmin1,paramFmin2,paramFmin3};
ctimes={ctimeFmin1,ctimeFmin2,ctimeFmin3};
errors={errFmin1,errFmin2,errFmin3};
methods={'ga','ga + fmincon','fmincon 2'};
end